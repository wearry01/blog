<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wearry&#39;s Blog</title>
    <link>http://localhost:1313/blog/</link>
    <description>Recent content on Wearry&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Wearry &gt;_ 2023</copyright>
    <lastBuildDate>Fri, 26 Apr 2024 16:48:45 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>平面树计数</title>
        <link>http://localhost:1313/blog/posts/count-plane-tree/</link>
        <pubDate>Fri, 01 Dec 2017 11:03:04 +0000</pubDate>
        
        <guid>http://localhost:1313/blog/posts/count-plane-tree/</guid>
        <description>Wearry&#39;s Blog http://localhost:1313/blog/posts/count-plane-tree/ -&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 \(N\), 求 \(N\) 个点的本质不同的平面树的数量.&lt;/p&gt;
&lt;p&gt;两棵平面树是等价的当且仅当其中一棵能够移动点的位置与另一棵重合, 且过程中仍然是一棵平面树——即在平面内边不交错地进行平移.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;做法&#34;&gt;做法&lt;/h2&gt;
&lt;p&gt;考虑模型转化 (计算 \(N+1\) 个点的答案):
取单位圆, 等距地取 \(2N\) 个点, 然后将这些点两两配对连边, 满足所有连边不相交.
发现它的对偶图恰好是一棵平面树, 像这样:&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;http://localhost:1313/blog/images/plane-tree.png&#34;&gt;
&lt;/figure&gt;

&lt;p&gt;那么就只需要考虑本质不同的这样的配对的数量即可.
两个圆是等价的当且仅当一个圆可以通过旋转一定的角度与另一个圆重合.
而在这个圆上共有 \(2N\) 个点, 就意味着有 \(2N\) 个置换, 构成一个置换群.&lt;/p&gt;
&lt;p&gt;置换群下的计数可以用到 Burnside引理 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$$ N(G, C) = \frac{1}{|G|} { \sum_{f \in G} c(f) } $$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;则转化为求置换下的不动点的数量:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不存在置换的情况下, 答案为 Catalan 数的第 \(N\) 项 \(C_N\).
即将相互匹配的位置看作左右括号, 则所有合法的括号序列都对应一个满足条件的圆.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;\(N\) 为奇数时, 可能存在一条平分圆的对角线在置换下不变, 计算 \(\frac{N+1}{2}\) 个点的答案即可.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑旋转置换:&lt;/p&gt;
&lt;p&gt;为了满足旋转之后的边重合, 点 \(i\) 和它的匹配点 \(p_i\) 在旋转后应该仍然是相匹配的.
则环的数量一定是偶数 \(2d\), 所以环的长度可以表示为 \(\frac{2N}{2d} = \frac{N}{d}\).&lt;/p&gt;
&lt;p&gt;假定置换的阶是 \(e\), \(e &amp;gt; 1, e | N\), 环的数量 \(2d = \frac{2N}{e}\).
环上与 \(0\) 匹配的点为 \(i\), 不难发现在这些点之间的点的方案数为 \(C_{i-1}\).
当这些点确定之后, 它们在环上依次经过的 \(e(i+1)\) 个点就确定了.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;令 \(f(x)\) 表示 Catalan 数的生成函数, 根据 Catalan 数的递推式得到:&lt;/p&gt;
&lt;p&gt;$$ f(x) = xf^2(x) + 1 $$&lt;/p&gt;
&lt;p&gt;构造 \(B_d\) 表示包含 \(2d\) 个环的置换下不动点的数量.&lt;/p&gt;
&lt;p&gt;$$ B_d = 2\sum_{i = 0}^{d-1} C_i B_{d-i-1} $$&lt;/p&gt;
&lt;p&gt;其中因子 \(2\) 考虑的是 \(i &amp;gt; 2d\) 时用当前置换的逆来计算的情况.&lt;/p&gt;
&lt;p&gt;则 \(B_d\) 的生成函数 \(g(x)\) 满足:&lt;/p&gt;
&lt;p&gt;$$ g(x) = 2x g(x) f(x) + 1 $$&lt;/p&gt;
&lt;p&gt;解得:&lt;/p&gt;
&lt;p&gt;$$ g(x) = (1 - 4x) ^ {-\frac{1}{2}} $$&lt;/p&gt;
&lt;p&gt;于是总的生成函数可以写成:&lt;/p&gt;
&lt;p&gt;$$ p(n) = \frac{1}{2n} \left( [\mathrm{n , is , odd}]\binom{n}{\lfloor\frac{n}{2}\rfloor} - \binom{2n}{n-1} + \sum_{d|n}{\varphi(n/d)\binom {2d}{d}} \right)$$&lt;/p&gt;
- http://localhost:1313/blog/posts/count-plane-tree/ - Wearry &gt;_ 2023</description>
        </item>
    
    
    
        <item>
        <title>写在NOIP2017之后</title>
        <link>http://localhost:1313/blog/posts/after-noip-2017/</link>
        <pubDate>Mon, 13 Nov 2017 08:24:59 +0000</pubDate>
        
        <guid>http://localhost:1313/blog/posts/after-noip-2017/</guid>
        <description>Wearry&#39;s Blog http://localhost:1313/blog/posts/after-noip-2017/ -&lt;h2 id=&#34;比赛过程&#34;&gt;比赛过程&lt;/h2&gt;
&lt;h3 id=&#34;day1&#34;&gt;Day1&lt;/h3&gt;
&lt;p&gt;T1一眼没有想出来, 心里还是有点虚, 认真地读完了后面两题平复了一下心态.
想着既然是T1应该不会太难, 看着样例找了找规律, 推了个 \(a + b + (b \bmod a) (a \lt b)\) 的方法, 发现过不了大样例. 于是盯着大样例发呆, 突然发现了世界的奥秘.
然后写T2, 写完眼查了一下大样例, 正要关闭窗口的时候习惯性 diff 了一下, 发现自己大小写写错一大堆&amp;hellip;
T3想了想写了个不考虑零边的记忆化搜索, 发现大样例过不了. 认真思考了一下发现是没有考虑到达终点又折返的情况, 又想了想发现 -1 挺好判的, 就加上了.&lt;/p&gt;
&lt;h3 id=&#34;day2&#34;&gt;Day2&lt;/h3&gt;
&lt;p&gt;到达考场时精神状态不太好, 意识模糊地打开了题目.
看完T2一直在想MST什么的, 感觉不太会做准备放弃时发现数据范围只有12, 于是秒懂了.
T3没想多久推出一个平衡树的做法, 对自己代码能力过于自信没有多想就开始写, 结果调到最后一刻还是GG了.&lt;/p&gt;
&lt;h2 id=&#34;反思错误&#34;&gt;反思错误&lt;/h2&gt;
&lt;p&gt;感觉这次虽然题目比较奇怪, 但实际难度还是合理的, 出现了一些失误恰恰暴露出身上的一些问题.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考试的时候大部分处在一种边想边写的状态, 一边写可能还要一边完善一些细节.&lt;/li&gt;
&lt;li&gt;刷了很多奇怪的考察思维的题目之后, 写数据结构的代码能力退化明显.&lt;/li&gt;
&lt;li&gt;&lt;del&gt;考场的 &lt;code&gt;debuff&lt;/code&gt; 比较强&lt;/del&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能后面两条还稍微可以接受吧, 但是第一条的确是硬伤, 这样做简单题或者在比较清醒的时候写题可能还好,  然而一旦遇到代码实现比较复杂或者条件比较多的题目, 就会挂得很惨, 这个问题模拟赛中也出现过几次.
解决的策略其实说起来也不难, 主要就是每道题写之前把算法细节考虑基本清楚, 做到 &lt;code&gt;Think twice, Code once&lt;/code&gt; 吧. 这样也不会出现某道题写了很久最后发现做法是错误的这种尴尬的情况也能够避免写一些特别复杂的做法.&lt;/p&gt;
&lt;h2 id=&#34;关于未来&#34;&gt;关于未来&lt;/h2&gt;
&lt;p&gt;针对这次联赛的问题和原来的一些弱点, 对接下来的一段学习做一些规划：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补一些数学相关的知识（不一定OI相关）&lt;/li&gt;
&lt;li&gt;提高一下代码能力, 复习一些不熟练的数据结构, 刷一些质量比较高的题目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后的话, 回去就要补文化了吧.&lt;/p&gt;
- http://localhost:1313/blog/posts/after-noip-2017/ - Wearry &gt;_ 2023</description>
        </item>
    
    
    
        <item>
        <title>Atcoder 选做</title>
        <link>http://localhost:1313/blog/posts/atcoder-select/</link>
        <pubDate>Fri, 30 Jun 2017 21:33:45 +0000</pubDate>
        
        <guid>http://localhost:1313/blog/posts/atcoder-select/</guid>
        <description>Wearry&#39;s Blog http://localhost:1313/blog/posts/atcoder-select/ -&lt;h1 id=&#34;agc&#34;&gt;AGC&lt;/h1&gt;
&lt;h2 id=&#34;agc002-f-leftmost-ball&#34;&gt;AGC002 F Leftmost Ball&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你\(N\)种不同颜色的球, 每种有\(K\)个, 现在你可以将球任意排列, 但最终的序列中每种颜色的第一个出现位置要被染成\(0\)颜色, 求能够得到的本质不同的序列数, 对\(10^9 + 7\)取模.&lt;/p&gt;
&lt;p&gt;\(N, K \leq 2000\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题正着处理没有什么思路, 但是如果从右往左来会比较好考虑.
我们可以记\(f(i, j)\)表示当前从右往左填剩下\(i\)个\(0\)颜色的球, 还剩下\(j\)种颜色没有放的方案数.
那么每一次的决策就包括放入一个\(0\)颜色的球以及添加一种颜色的\(k-1\)个球:&lt;/p&gt;
&lt;p&gt;\begin{aligned}
f(i-1, j) &amp;amp; \leftarrow f(i, j) \mid [i &amp;gt; j] \\
f(i, j-1) &amp;amp; \leftarrow f(i, j) \times {n-i + (n-j) \times (k-1) + k-2 \choose k-2}
\end{aligned}&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后面那个公式是可重集, 还有最后的答案要乘以 \(n!\).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;agc005-d-k-perm-counting&#34;&gt;AGC005 D ~K Perm Counting&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;求长度为\(N\)的排列中, 满足对任意的\(i\), 都有\(|a_i - i| \neq K\)的排列数量.&lt;/p&gt;
&lt;p&gt;\(1 \leq K \lt N \leq 2000\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑容斥, 计算至少有\(i\)个位置不合法的方案数. 由于\(K\)是确定的, 那么所有不合法的方案可以看成是完全二分图匹配中出现了一条\((i, i+k)\)的边或者一条\((i, i-k)\)的边.&lt;/p&gt;
&lt;p&gt;将这样的边在画出来就是若干条交叉路径. 观察到这样的交叉路径不相交, 所以可以拆开拼成一个序列, 然后在序列上DP即可.&lt;/p&gt;
&lt;h2 id=&#34;agc015-d-a-oror-b-problem&#34;&gt;AGC015 D A or&amp;hellip;or B Problem&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;求在\([A, B]\)中任意选出一个非空整数集合的元素位或和有多少种不同的答案.&lt;/p&gt;
&lt;p&gt;\(1 \le A \le B \le 2^{60}\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先考虑一些比较特殊的情况(以下默认\(A, B\)的位数相同):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当\(B\)可以表示为\(2^k - 1\)时, 这个位或和恰好取遍\([A, B]\)之间的所有整数.&lt;/li&gt;
&lt;li&gt;当\(A\)可以表示为\(2^k\)时, 这个位或和在区间\([A, A + 2^{t+1}) \mid t \lt \log_2 A\)中, 其中\(t\)是最大的满足\(B\)的第\(t\)位为\(1\)的数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么一般情况下这些条件有什么用呢?&lt;/p&gt;
&lt;p&gt;我们考虑找到最大的一个\(T\),使得\(B\)的第\(T\)位为\(1\)且\(A\)的第\(T\)位不为\(1\), 记\(K = 2 ^ T\). 当选择的数的集合在\([A, K)\)以及在\([K, B]\)中的情况可以直接用上述结论.&lt;/p&gt;
&lt;p&gt;接下来考虑同时选取两个集合中的数可能会产生的答案. 因为这时小于\(K\)的部分是没有贡献的, 所以直接将\([A, K)\)中的所有答案取出. 不难发现\([K, B]\)中取任意个都与只使用\(K\)没有区别, 那么这时候的范围是\([K+A, 2\times K-1]\), 注意减去重复贡献.&lt;/p&gt;
&lt;h2 id=&#34;agc015-f-kenus-the-ancient-greek&#34;&gt;AGC015 F Kenus the Ancient Greek&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;\(Q\) 组询问, 每组询问的形式为A, B, 表示求\(x \in [1, A], y \in [1, B]\)的\(g(x, y)\)的最大值, 及最大值的方案数, 其中:&lt;/p&gt;
&lt;p&gt;\[ g(x, y) = \begin{cases} 1, &amp;amp; \text{y = 0} \\ g(y, x), &amp;amp; \text{x &amp;gt; y} \\ g(y \bmod x, x) + 1, &amp;amp; \text{otherwise} \\ \end{cases} \]&lt;/p&gt;
&lt;p&gt;\(1 \le Q \le 3 \times 10 ^ 5,  1 \le A, B \le 10 ^ {18}\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;以下无特殊说明, 均默认所有\(x &amp;lt; y, A &amp;lt; B\)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先考虑第一问, 如果我们由一个特定的\((x, y)\), 从小到大地构造使得\(g(x, y)\)的值不断地变大, 那么如何构造使得这个值最大呢?
对于所有\((x&amp;rsquo;, y&amp;rsquo;)\)满足\(g(x&amp;rsquo;, y&amp;rsquo;) = g(x, y) + 1\), 显然有:
$$
(x&amp;rsquo;, y&amp;rsquo;) \in \{ (y, x + ky) \mid k \in Z^+ \}
$$
同时, 为了使得这个过程尽可能的多次进行,我们从\((0, 1)\)出发, 每次取\(k = 1\).
发现这样生成了一组&lt;code&gt;Fibonacci&lt;/code&gt;数列, 这里&lt;code&gt;Fibonacci&lt;/code&gt;数列从0开始标号.
那么第一问的答案就是求满足\(F_k \le A, F_{k+1} \le B\)的最大的\(k\). 同时, 这样的数对是满足\(g(x, y) = k\)的最小的数对.
接下来考虑统计方案数. 首先, 对于一组询问我们只需考虑其中&lt;strong&gt;与最优解相关&lt;/strong&gt;的\((x, y)\).
考虑所有最优的\((x, y)\)会具有的性质:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\(x \ge F_k, y \ge F_{k+1}\)&lt;/li&gt;
&lt;li&gt;不存在一组\((x&amp;rsquo; \lt x, y&amp;rsquo; \lt y)\), 使得\(g(x&amp;rsquo;, y&amp;rsquo;) &amp;gt; g(x, y)\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而这样的\((x, y)\)并不一定是最优的.
我们接着分析所有在最优解的\(g\)的计算路径上的数对\((x, y)\)的性质: 不难发现, 经过一次变化后得到的\((x&amp;rsquo;, y&amp;rsquo;)\), 一定满足:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\(g(x&amp;rsquo;, y&amp;rsquo;) = k-1\)&lt;/li&gt;
&lt;li&gt;\(x&amp;rsquo; \ge F_{k-1}, y&amp;rsquo; \ge F_{k}\)&lt;/li&gt;
&lt;li&gt;\(y&amp;rsquo; \le F_{k+1} + F_{k-2}\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面条件的解释: 若\(y&amp;rsquo; &amp;gt; F_{k+1} + F_{k-2}\), 则:
$$
(x, y) = (y&amp;rsquo; &amp;gt; F_{k+1} + F_{k-2} &amp;gt; F_{k+1}, x&amp;rsquo; + py&amp;rsquo; \ge x&amp;rsquo; + y&amp;rsquo; &amp;gt; F_{k+2})
$$
\((x, y)\)不再满足上述最优性质2, 矛盾.
同时每次向下一步进行构造的时候只有\((Fib_k, Fib_{k+1})\)可能取到\(p = 2\)所以这样的数对个数是\(O(k)\)的. 所以我们预处理所有的这样的数对, 然后用除法算下答案就好了.
复杂度\(O(\log^2{\text{MAX}} + Q\log \text{MAX})\).&lt;/p&gt;
&lt;h1 id=&#34;arc&#34;&gt;ARC&lt;/h1&gt;
&lt;p&gt;ARC 的题目主要来源是打过的几场比赛, 暂时不多.&lt;/p&gt;
&lt;h2 id=&#34;arc074-e-rgb-sequence&#34;&gt;ARC074 E RGB Sequence&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个长度为\(N\)的序列和\(M\)组约束条件, 每组条件形如\(L_i, R_i, X_i\), 表示序列上的\([L_i, R_i]\)中恰好有\(X_i\)种颜色, 现在要你用三种颜色给这个序列染色, 求满足所有约束的方案数.&lt;/p&gt;
&lt;p&gt;\(1 \le N, M \le 300\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DP思路应该比较显然, 然而普通的状态表示不太好处理. 我们记\(dp_{r, g, b}\)表示三种颜色的球最后一次出现的位置分别是\(r, g, b\)时的方案数.&lt;/p&gt;
&lt;p&gt;然后考虑状态的合法性, 可以把条件存在\(R_i\)的位置. 当选择一个状态时, 考虑这个状态的最末位的所有约束即可.&lt;/p&gt;
&lt;h2 id=&#34;arc077-f-ss&#34;&gt;ARC077 F SS&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;定义一个字符串为偶的, 当且仅当这个字符串能够被分成两个完全相同的字符串.&lt;/p&gt;
&lt;p&gt;定义函数\(f(s)\), 其中\(s, f(s)\)均是字符串,\(f(s)\)为在字符串\(s\)后添加非空的字符满足新串为偶且长度最小的串. 现在给你串\(s\)(初始为偶的), 求\(f^{10^{100}}(s)[L, R]\)中各个字母的出现次数.&lt;/p&gt;
&lt;p&gt;\(1 \le |S| \le 2\times 10^5\)&lt;/p&gt;
&lt;p&gt;\(1 \le L \le R \le 10^{18}\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先对于一个给定的\(s\), 其\(f(s)\)必定唯一. 考虑每次最少加一个字符,\(f^{10^{100}}(s)\)就等价于一个长度无穷的字符串. 这个答案的形式显然可以前缀和, 又因为\(s\)在变化过程中始终是偶的, 实际上我们只需要关注左半部分的字符.&lt;/p&gt;
&lt;p&gt;我们从最简单的一次操作来考虑. 记初始的字符串\(s\)为\(SS\), 记一次变化之后左边的部分为\(ST\), 那么得到的新串就是\(STST\). 要使得加的字符长度最小, 就要在\(S\)中找到最长前后缀匹配长度, 这时\(T\)就是\(S\)去掉最长匹配后缀所得.&lt;/p&gt;
&lt;p&gt;我们发现, 每次操作都等价于找到前后缀匹配最大长度(当然要小于\(|S|\)), 然后将剩下部分的前缀\(T\)添加到\(S\)的末尾.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当\(|T| \mid |S|\)时,\(|S|\)有长为\(|T|\)的最小周期, 每次加入的\(|T|\)相同.&lt;/li&gt;
&lt;li&gt;当\(|T| \nmid|S|\)时, 我们&lt;del&gt;通过打表&lt;/del&gt;发现, 这样的\(T\)是在有规律地变化的, 因为每次加入\(T\)之后的串前后缀最长匹配一定是\(|T|\), 否则的话, 上一步中最长匹配的性质就不一定会满足.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后我们得到了一个&lt;code&gt;Fibonacci&lt;/code&gt;数列? 直接暴力算就好了&amp;hellip; 实际上第一种情况也可以直接算, 因为整个序列都是\(T\)的若干次重复得到的.&lt;/p&gt;
- http://localhost:1313/blog/posts/atcoder-select/ - Wearry &gt;_ 2023</description>
        </item>
    
    
  </channel>
</rss> 