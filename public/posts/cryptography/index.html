<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Cryptography Notes | Wearry&#39;s Blog</title>


<link rel="stylesheet" href="/assets/combined.min.e962532feeb5740101e74674a3b76810a4b11df3e73378622fd233e3e9f06c82.css" media="all">


<link rel="stylesheet" href="/css/justifiedGallery.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>


<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],
      inlineMath: [['\\[', '\\]'], ['$', '$'], ['\\(', '\\)']]
    }
  };
</script>




</head>







<body class="auto">

  <div class="content">
    <header>
      

<div class="header">
    <h1 class="header-title">Wearry&#39;s Blog</h1>
    <h3 class="header-subtitle">ÈïøÊÅ®Ê≠§Ë∫´ÈùûÊàëÊúâ</h3>

    <div class="flex">
        

        
        
        <p class="small ">
            <a href="/">
                /home
            </a>
        </p>
        
        <p class="small ">
            <a href="/posts">
                /posts
            </a>
        </p>
        
        <p class="small ">
            <a href="/photos">
                /photos
            </a>
        </p>
        
        
    </div>

</div>

    </header>

    <main class="main">
      



<div >

  <div class=" single-intro-container">

    

    <h1 class="single-title">Cryptography Notes</h1>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2020-07-07T21:37:14&#43;00:00">July 7, 2020</time>
      -
      
      
    </p>

  </div>

  

  
  <aside class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#probability-distribution"><em>Probability Distribution</em></a></li>
    <li><a href="#event"><em>Event</em></a>
      <ul>
        <li><a href="#the-union-bound"><em>The Union Bound</em></a></li>
      </ul>
    </li>
    <li><a href="#random-variable"><em>Random Variable</em></a>
      <ul>
        <li><a href="#uniform-random-variable"><em>Uniform Random Variable</em></a></li>
      </ul>
    </li>
    <li><a href="#independence"><em>Independence</em></a></li>
    <li><a href="#more-about-probability"><em>More about Probability</em></a></li>
  </ul>

  <ul>
    <li><a href="#pseudo-random-generator"><em>Pseudo-random Generator</em></a>
      <ul>
        <li><a href="#security"><em>Security</em></a></li>
      </ul>
    </li>
    <li><a href="#pseudo-random-function"><em>Pseudo-random Function</em></a>
      <ul>
        <li><a href="#notation"><strong>Notation</strong></a></li>
        <li><a href="#attack-game-prf"><em>Attack Game (PRF)</em></a></li>
      </ul>
    </li>
    <li><a href="#pseudo-random-permutation"><em>Pseudo-random Permutation</em></a></li>
  </ul>

  <ul>
    <li><a href="#stream-cipher"><em>Stream Cipher</em></a>
      <ul>
        <li><a href="#otp"><em>One Time Pad</em></a></li>
      </ul>
    </li>
    <li><a href="#perfect-secrecy"><em>Perfect Secrecy</em></a>
      <ul>
        <li><a href="#stream-cipher-in-practice"><em>Stream Cipher in Practice</em></a></li>
      </ul>
    </li>
    <li><a href="#bc"><em>Block Cipher</em></a>
      <ul>
        <li><a href="#attack-game-prp--security"><em>Attack Game (PRP) &amp; Security</em></a></li>
        <li><a href="#practice">Practice</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#message-authentication-code-mac"><em>Message Authentication Code (MAC)</em></a></li>
    <li><a href="#security-of-macs"><em>Security of MACs</em></a></li>
  </ul>
</nav>
  </aside>
  

  

  <div class="single-content">
    <p>Some notes of üîí cryptography lessons</p>
<p><strong>TODO</strong>:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Reconstruct the architecture of this post</li>
<li>Complete other contents
<ul>
<li><input checked="" disabled="" type="checkbox"> I: Pseudorandomness</li>
<li><input checked="" disabled="" type="checkbox"> II: Cipher</li>
<li><input disabled="" type="checkbox"> III: MAC</li>
<li><input disabled="" type="checkbox"> IV: Attack &amp; Security</li>
<li><input disabled="" type="checkbox"> V: Public-key Cryptography</li>
</ul>
</li>
</ul>
<h1 id="preliminary-fundamental-discrete-probability"><em>Preliminary: Fundamental Discrete Probability</em></h1>
<p>Suppose $U$ is a finite set.</p>
<h2 id="probability-distribution"><em>Probability Distribution</em></h2>
<blockquote>
<p>a <code>probability distribution</code> $P$ over $U$ is a function
$$P: U \rightarrow [0,1]$$
s.t.
$$\sum_{x \in U} P(x) = 1$$</p>
</blockquote>
<p>Some examples:</p>
<ul>
<li>Uniform distribution: $\forall x \in U, P(x) = \dfrac{1}{|U|}$</li>
<li>Pointed distribution: $\exists x \in U, P(x) = 1$</li>
</ul>
<h2 id="event"><em>Event</em></h2>
<blockquote>
<p>an <code>event</code> is a subset $E$ of $U$, define the probability of $E$ under <code>probability distribution</code> $P$ as below:
$$Pr[E] = \sum_{x \in E} P(x)$$</p>
</blockquote>
<h3 id="the-union-bound"><em>The Union Bound</em></h3>
<p>By definition, we can obviously get:</p>
<p>$$Pr[A_1 \cap A_2] + Pr[A_1 \cup A_2] = Pr[A_1] + Pr[A_2]$$</p>
<p>Which also implies that:</p>
<p>$$Pr[A_1 \cup A_2] \le Pr[A_1] + Pr[A_2]$$</p>
<h2 id="random-variable"><em>Random Variable</em></h2>
<blockquote>
<p>a <code>random variable</code> $X$ is a function
$$X:U \rightarrow V$$
where $V$ is <strong>range</strong> of $X$</p>
</blockquote>
<p>Example <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>:</p>
<p>$$
\begin{aligned}
X:{0, 1}^n \rightarrow {0, 1} \
X(b) = LSB(b) \in {0, 1}
\end{aligned}
$$</p>
<p>As you can see, <code>random variable</code> $X$ can also induce <code>probability distribution</code> from $U$ to $V$ (Suppose $P$ is a distribution on $U$):</p>
<p>$$
\forall v \in V, Q(v) = Pr[X = v] = Pr[X^{-1}(v)]
$$</p>
<h3 id="uniform-random-variable"><em>Uniform Random Variable</em></h3>
<p>Specially, when $P$ is uniform distribution and $X(r) = r$ for all $r \in U$, then:</p>
<p>$$
\forall r \in U, Pr[X = r] = \frac{1}{|U|}
$$</p>
<p>this is called <code>uniform random variable</code>, denoted by $X \xleftarrow{R} U$</p>
<h2 id="independence"><em>Independence</em></h2>
<ul>
<li>Two <code>events</code> $A, B$ are independent <strong>iff</strong>: $Pr[A \cap B] = Pr[A] \times Pr[B]$</li>
<li>Two <code>random variables</code> $A, B$ are independent <strong>iff</strong> $\forall a \in V_A, b \in V_B$:</li>
</ul>
<p>$$
Pr[A = a ,,\mathrm{and},, B = b] = Pr[A = a] \times Pr[B = b]
$$</p>
<blockquote>
<p>For better understanding of independence, consider the example below:
Suppose a dice numbered by $D = {1, 2, \dots, 6}$ and 2 <code>random variables</code> $A, B$:
$$ \begin{aligned}
&amp;A:D \rightarrow {0, 1} &amp;A(x) = [x \equiv 0 \pmod 2] \
&amp;B:D \rightarrow {0, 1} &amp;B(x) = [x \equiv 0 \pmod 3]
\end{aligned} $$
For uniform distribution of $D$, $A, B$ are obviously independent. Think about conditions below:</p>
<ol>
<li>$B(x) = [x \equiv 0 \pmod 4]$</li>
<li>$D = {1, 2, \dots, 5}$</li>
</ol>
</blockquote>
<h2 id="more-about-probability"><em>More about Probability</em></h2>
<p><a href="https://crypto.stanford.edu/~blynn/pr/">See also</a></p>
<h1 id="i-pseudorandomness"><em>I: Pseudorandomness</em></h1>
<p><code>Pseudorandomness</code> measures the extent to which a sequence of numbers, though produced by a completely deterministic and repeatable process, appear to be patternless.</p>
<h2 id="pseudo-random-generator"><em>Pseudo-random Generator</em></h2>
<p>A <code>Pseudo-random Generator</code>, or <code>PRG</code> for short, is an efficient, deterministic algorithm $G$ that given as input a <code>seed</code> $s$, computes an output $r$.
Both $s$ and $r$ come from a finite space, called $\mathcal{S}$ and $\mathcal{R}$ respectively.</p>
<p>Typically $\mathcal{S}$ and $\mathcal{R}$ are sets of bit strings of some prescribed length. We can also regard $G$ as an abstract function defined over $\mathcal{(S, R)}$:</p>
<p>$$
G: \mathcal{S} = {0, 1}^l \rightarrow \mathcal{R} = {0, 1}^L
$$</p>
<h3 id="security"><em>Security</em></h3>
<p>We say a PRG $G$ is secure if $G(s)$ and $r$ are <strong>computational indistinguishable</strong>, among which $s$ is chosen uniform randomly from $\mathcal{S}$ and $r$ is chosen at random from $\mathcal{R}$.</p>
<p>To illustrate <strong>computational indistinguishability</strong>, the definition is formulated as an attack game:</p>
<blockquote>
<h4 id="attack-game-prg-and-advantage"><em>Attack Game (PRG) and Advantage</em></h4>
<p>For a given PRG $G$ defined over $\mathcal{(S, R)}$,
and for a given adversary $\mathcal{A}$,
we define two experiments, Experiment $0$ and Experiment $1$:</p>
<p><strong>Experiment</strong> $b$:</p>
<ul>
<li>
<p>The Challenger computes $r \in \mathcal{R}$ as follows:




<figure   >
    <img loading="lazy" alt="PRG-ADV" src=" /images/PRG-ADV.png">
</figure></p>
<ul>
<li>if $b = 0$, $s \xleftarrow{R} \mathcal{S}, r \leftarrow G(s)$</li>
<li>if $b = 1$, $r \xleftarrow{R} \mathcal{R}$</li>
</ul>
</li>
<li>
<p>Given $r$, the adversary computes and outputs a bit $\hat{b} \in {0, 1}$</p>
</li>
</ul>
<p>For $b \in {0, 1}$, let $W_b$ be the event that $\mathcal{A}$ outputs $\hat{b} = 1$ in Experiment $b$. We define $\mathcal{A}$&rsquo;s <code>advantage</code> with respect to $G$ as</p>
<p>$$
PRG_{adv} [\mathcal{A}, G] = \left|Pr[W_0] - Pr[W_1]\right|
$$</p>
</blockquote>
<p>Now we can define a PRG $G$ is <strong>secure</strong> if the value $PRG_{adv} [\mathcal{A}, G]$ is negligible <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> for all efficient adversaries $\mathcal{A}$.</p>
<h2 id="pseudo-random-function"><em>Pseudo-random Function</em></h2>
<p>A <code>Pseudo-random Function(PRF)</code> $F$ is a deterministic algorithm that has two inputs: a <code>key</code> $k$ and an <code>input data block</code> $x$; its output $y := F(k, x)$ is called an
<code>output data block</code>. We denote the finite space of $k, x, y$ with $(\mathcal{K, X, Y})$, over which is $F$ defined.</p>
<p>Intuitively, our notion of security says that for a randomly chosen key $k$, $F(k, \cdot )$ is indistinguishable from a random function from $\mathcal{X}$ to $\mathcal{Y}$</p>
<blockquote>
<h3 id="notation"><strong>Notation</strong></h3>
<p>$$
Funs[\mathcal{X, Y}] = {f: \mathcal{X} \rightarrow \mathcal{Y}}
$$
clearly we know that
$$
|Funs[\mathcal{X, Y}]| = |\mathcal{Y}|^{|\mathcal{X}|}
$$</p>
</blockquote>
<h3 id="attack-game-prf"><em>Attack Game (PRF)</em></h3>
<p>Similarly we can define two experiments, Experiment $0$ and $1$, for a PRF $F$ defined over $(\mathcal{K, X, Y})$:</p>
<p><strong>Experiment</strong> $b$:</p>
<ul>
<li>The challenger selects $f$ as follows:
<ul>
<li>if $b = 0$, $k \xleftarrow{R} \mathcal{K}, f \leftarrow F(k, \cdot)$</li>
<li>if $b = 1$, $f \xleftarrow{R} Funs[\mathcal{X, Y}]$</li>
</ul>
</li>
<li>The adversary $\mathcal{A}$ submits a sequence of queries $x_1, \dots, x_q$, and receives $y_i = f(x_i)$ for each $i$ from the challenger</li>
<li>The adversary computes $\hat{b} \in {0, 1}$</li>
</ul>
<p>Let $W_b$ be the event $\mathcal{A}$ outputs $1$ in Experiment $b$, the <code>advantage</code> is also defined by:</p>
<p>$$
PRF_{adv} [\mathcal{A}, F] = |Pr[W_0] - Pr[W_1]|
$$</p>
<p>We say a PRF $F$ is <strong>secure</strong> if all efficient adversary $A$ have a negligible advantage.</p>
<h2 id="pseudo-random-permutation"><em>Pseudo-random Permutation</em></h2>
<p>Also called <a href="#bc">Block Cipher</a>, is a special PRF which is also invertible.</p>
<h1 id="ii-cipher"><em>II: Cipher</em></h1>
<p>Throughout history, there were many ways of encryption, however, some of them have been proved unsafe. The question now is whether a particular <code>cipher</code> is <strong>secure</strong> and how to construct a <strong>secure</strong> one.</p>
<blockquote>
<p>A <code>cipher</code> defined over a triple $(\mathcal{K, M, C})$ is a pair of <strong>efficient</strong><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> algos $(E, D)$ where:</p>
<p>$$
\begin{aligned}
E: \mathcal{K \times M} \rightarrow \mathcal{C} \
D: \mathcal{K \times C} \rightarrow \mathcal{M}
\end{aligned}
$$
s.t. $\forall m \in \mathcal{M}, k \in \mathcal{K}$
$$
m = D(k, E(k, m))
$$
and $\mathcal{K, M, C}$ denote the space of keys, messages and cipher texts.</p>
</blockquote>
<h2 id="stream-cipher"><em>Stream Cipher</em></h2>
<p>The example below shows the basic idea of stream cipher.</p>
<h3 id="otp"><em>One Time Pad</em></h3>
<p>An example cipher over $\mathcal{K, M, C} = {0, 1}^n$ and:</p>
<p>$$
\begin{aligned}
E(k, m) &amp;= k \oplus m \
D(k, c) &amp;= k \oplus c \
\end{aligned}
$$</p>
<h2 id="perfect-secrecy"><em>Perfect Secrecy</em></h2>
<p>The basic idea behind perfect secrecy is: cipher text should reveal no &ldquo;info&rdquo; about plain text.</p>
<blockquote>
<p>A <code>cipher</code> $(E, D)$ over ${\mathcal{K, M, C}}$ has <code>perfect secrecy</code> <strong>iff</strong>:</p>
<p>$\forall m_0, m_1 \in \mathcal{M} ,,\mathrm{that},, |m_0| = |m_1|, c \in \mathcal{C}$:
$$Pr[E(k, m_0) = c] = Pr[E(k, m_1) = c]$$
where $k \xleftarrow{R} \mathcal{K}$</p>
</blockquote>
<p>It&rsquo;s not hard to see that when attacker gets a cipher text, he will have no idea what the plain text is. By definition, we can also prove <a href="#otp">One Time Pad</a> has <code>perfect secrecy</code>.</p>
<p>However, <code>perfect secrecy</code> is too hard to satisfy because we have theorem says:</p>
<blockquote>
<p>If a <code>cipher</code> has <code>perfect secrecy</code>, then:
$$|\mathcal{K}| \ge |\mathcal{M}|$$
which means the length of keys mustn&rsquo;t less than length of messages.</p>
</blockquote>
<p>That somehow makes no sense for if we have some way sending and receiving such long keys secretly, then it&rsquo;s absolutely unnecessary to use <code>cipher</code>.</p>
<h3 id="stream-cipher-in-practice"><em>Stream Cipher in Practice</em></h3>
<p>However, <code>One Time Pad</code> is not mainly used in practice because:</p>
<ol>
<li>The key space $\mathcal{K}$ is as large as message space $\mathcal{M}$, which makes no sense in communication.</li>
<li>For two same message segments in different positions, they would also be same in the cipher text.</li>
</ol>
<p>In practice, we have to change some details to solve these problems:</p>
<ol>
<li>
<p>We can implement a <code>PRF</code> $G$ with seed space $\mathcal{S}$ much less than the message space $\mathcal{M}$, and rewrite the process of encryption and decryption as:
$$
\begin{aligned}
E(k, m) &amp;= G(k) \oplus m \
D(k, c) &amp;= G(k) \oplus c
\end{aligned}
$$
By the properties of <code>PRF</code> we could argue the security.</p>
</li>
<li>
<p>To solve this problem, we can change the key after a fixed length of message or using a nonce, the later one will appear in remain chapters.</p>
</li>
</ol>
<h2 id="bc"><em>Block Cipher</em></h2>
<p>A <code>block cipher</code> defined over $(\mathcal{K, X})$ is a deterministic $(E, D)$ whose message space and cipher space is same (finite) set $\mathcal{X}$.
Additionally, for each $k \in \mathcal{K}$, it&rsquo;s necessary that $E(k, \cdot)$ is invertible,
which also means $f_k := E(k, \cdot)$ is an one-to-one map on finite set $\mathcal{X}$ and $D(k, \cdot) = f_k^{-1}$.</p>
<p>It&rsquo;s not hard to see that $D(k, E(k, m)) = m$, so the point now is to argue the security of <code>block cipher</code> (also called <code>Pseudo-random Permutation</code>, <code>PRP</code>).
Before that, let&rsquo;s focus on the properties of invertible function on a finite set $\mathcal{X}$:</p>
<ol>
<li>
<p>Some notation:
$$
Perm[\mathcal{X}] = {F \in Funs[\mathcal{X, X}] : F \text{ is invertible}}
$$</p>
</li>
<li>
<p>Obviously:
$$
|Perm[\mathcal{X}]| = |\mathcal{X}|!
$$</p>
</li>
</ol>
<h3 id="attack-game-prp--security"><em>Attack Game (PRP) &amp; Security</em></h3>
<p>Similarly with the idea used in attacking <code>PRF</code>,
we design an attack game for a certain <code>block cipher</code> (or <code>PRP</code>) $\mathcal{E} = (E, D)$ over $(\mathcal{K, X})$ against an attacker $\mathcal{A}$:</p>
<p>Experiment $b$:</p>
<ol>
<li>
<p>Challenger selects $f$ as follow</p>
<ul>
<li>if $b = 0$, $k \xleftarrow{R} \mathcal{K}, f = E(k, \cdot)$</li>
<li>if $b = 1$, $f \xleftarrow{R} Perm[\mathcal{X}]$</li>
</ul>
</li>
<li>
<p>Attacker choose a sequence of input $x_1, x_2, \dots, x_q$, and get $y_i = f(x_i)$ from the challenger.</p>
</li>
<li>
<p>Attacker output a $\hat{b} \in {0, 1}$.</p>
</li>
</ol>
<p>The advantage is defined as:</p>
<p>$$
BC_{ADV}[\mathcal{A, E}] = |Pr[W_0] - Pr[W_1]|
$$</p>
<p>where $W_b$ describe the event that $\mathcal{A}$ outputs $\hat{b} = 1$ in Experiment $b$,
$\mathcal{E}$ is <strong>secure</strong> if the advantage is negligible for all efficient algorithm $\mathcal{A}$.</p>
<h3 id="practice">Practice</h3>
<p>In practice, we often divide messages into &ldquo;blocks&rdquo;, then implement <code>block cipher</code> to them and concate to get the cipher text.</p>
<h1 id="iii-message-integrity"><em>III: Message Integrity</em></h1>
<p>In previous chapters, we mainly focused on security against an eavesdropping adversary, which could not change messages en-route.
In this chapter we turn out attention to active adversaries by startting with the basic question of <em>message integrity</em>: Bob receives a message $m$ from Alice,
and he wants to convince himself that the message was not modified en-route.</p>
<p>Alice could send a extra tag $t$ of message $m$ to Bob, when Bob receives the pair $(m, t)$,
he can determine that by recalculating the tag of $m$ and then checking whether it is $t$.</p>
<h2 id="message-authentication-code-mac"><em>Message Authentication Code (MAC)</em></h2>
<p>A <code>MAC</code> system $\mathcal{I} = (S,V)$ is a pair of efficient algorithms, $S$ and $V$, where $S$ is called a <code>signing algorithm</code> and $V$ is called a <code>verification algorithm</code>.
$S$ is used to generate tags and $V$ is to verify tags.</p>
<ul>
<li>$S$ is a probabilistic algorithm that is invoked as $t \xleftarrow{R} S(k, m)$, where $k$ is a key, $m$ is a message.</li>
<li>$V$ is a deterministic algorithm that is invoked as $r = V(k, m, t)$, where $k$ is a key, $m$ is a message, $t$ is a tag, and $r \in {0, 1}$</li>
<li>For all keys and all messages:</li>
</ul>
<p>$$
V(k, m, S(k, m)) = 1
$$</p>
<p>As usual, we say that keys, messages and tags lie in some finite key space $\mathcal{K, M, T}$. We say that $\mathcal{I} = (S, V)$ is defined over $\mathcal{K, M, T}$.</p>
<h2 id="security-of-macs"><em>Security of MACs</em></h2>
<p>Suppose an adversary is attacking a MAC system $\mathcal{I} = (S, V)$. Let $k$ be some randomly chosen MAC key, which is unknown to the attacker. We allow the attacker to request tags $t := S(k, m)$ for arbitrary messages $m$ of its choice. And the attacker need to come up with a <em>new</em> pair $(m, t)$ satisfies $V(k, m, t) = 1$.</p>
<h1 id="iv-attack--security"><em>IV: Attack &amp; Security</em></h1>
<h1 id="v-public-key-cryptography"><em>V: Public-key Cryptography</em></h1>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>LSB is a function which gets the last significant bit of a bit-string.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Negligible means small enough so that cannot be detected even by enormous samples.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Theoretically, efficient means runs in polynomial time; Practically it means runs within a certain time period.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
  </div>

</div>


    </main>
  </div>

  <footer>
    <p>Powered by
    <a href="https://gohugo.io/">Hugo</a>
    and
    <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    ¬© Wearry &gt;_ 2024
</p>
<script id="gallery-script" src="/js/gallery.js"></script>
  </footer>

</body>


<script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    console
    document.body.classList.remove("auto");
    let cls = "light";

    console.log

    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);

  }

  function invert() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    console.log("Setting invert listener");
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invert);
  }

  setTheme();

</script>


</html>