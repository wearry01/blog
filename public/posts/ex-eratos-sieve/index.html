<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>拓展埃氏筛法小结 | Wearry&#39;s Blog</title>


<link rel="stylesheet" href="/assets/combined.min.e962532feeb5740101e74674a3b76810a4b11df3e73378622fd233e3e9f06c82.css" media="all">


<link rel="stylesheet" href="/css/justifiedGallery.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>


<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],
      inlineMath: [['\\[', '\\]'], ['$', '$'], ['\\(', '\\)']]
    }
  };
</script>





  



</head>







<body class="auto">

  <div class="content">
    <header>
      

<div class="header">
    <h1 class="header-title">Wearry&#39;s Blog</h1>
    <h3 class="header-subtitle">长恨此身非我有</h3>

    <div class="flex">
        

        
        
        <p class="small ">
            <a href="/">
                /home
            </a>
        </p>
        
        <p class="small ">
            <a href="/posts">
                /posts
            </a>
        </p>
        
        <p class="small ">
            <a href="/photos">
                /photos
            </a>
        </p>
        
        
    </div>

</div>

    </header>

    <main class="main">
      



<div >

  <div class=" single-intro-container">

    

    <h1 class="single-title">拓展埃氏筛法小结</h1>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2018-08-21T19:42:41&#43;00:00">August 21, 2018</time>
      -
      
      
    </p>

  </div>

  

  
  <aside class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#description">Description</a></li>
    <li><a href="#conversion">Conversion</a></li>
    <li><a href="#code">Code</a></li>
  </ul>
</nav>
  </aside>
  

  

  <div class="single-content">
    <h2 id="description">Description</h2>
<p>求:</p>
<p>$$h(n) = \sum_{i=1}^{n} f(i)$$</p>
<p>其中 \(f\) 是定义在正整数集下的积性函数, 满足 \(f(p^c)\) 能够快速计算.</p>
<h2 id="conversion">Conversion</h2>
<p>首先可以将所有要求的数按照是否只含大于 \(\sqrt{n}\) 的质因子分为两类, 对于第一类数一定是一个质数, 而第二类数一定可以在某个较小的质因子处考虑到, 于是我们只关注不超过 \(\sqrt{n}\) 的那些质因子.</p>
<p>定义 \(S_k(n, i)\) 表示小于等于 \(n\) 的数中与前 \(i\) 个质数互质的所有数与<strong>所有质数</strong>的 \(k\) 次方和, 容易得到转移:</p>
<p>$$
S_k(n, i) =
\begin{cases}
S_k(n, i-1) &amp; n &lt; p_i^2 \\
S_k(n, i-1) - p_i^k \times \left(S_k(\left \lfloor \frac{n}{p_i} \right \rfloor, i - 1) - S_k(p_{i-1}, i - 1)\right) &amp; \mathrm{otherwise}
\end{cases}
$$</p>
<p>在考虑完 \(\sqrt{n}\) 以内的所有质因数后, \(S_k(n)\) 中留下了所有质数的 \(k\) 次方, 这样所有第一类数的函数值都可以快速计算.</p>
<p>类似地, 定义 \(G(n, i)\) 表示小于等于 \(n\) 的数中仅由第 \(i\) 个以后的质数构成的数与<strong>所有质数</strong> \(x\) 的 \(f(x)\) 之和, 转移的方式类似:</p>
<p>$$
G(n, i) = G(n, i+1) + \sum_{c=0}^{\substack{p_i^{c+1} \le n}} f(p_i^{c+1}) + f(p_i^c) \times \left(G(\left \lfloor \frac{n}{p_i^c} \right \rfloor, i+1) - G(p_i, i+1)\right)
$$</p>
<p>复杂度约为 \(O\left(\frac{n^{\frac{3}{4}}}{\log{n}}\right)\)</p>
<h2 id="code">Code</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> M = 100000;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ll n;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> m;
</span></span><span style="display:flex;"><span>uint val[M + 5];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> prime[M + 5], pcnt;
</span></span><span style="display:flex;"><span>uint s[M + 5], S[M + 5];
</span></span><span style="display:flex;"><span>uint f[M + 5], F[M + 5];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">inline</span> uint <span style="color:#666;font-weight:bold;font-style:italic">gets</span>(ll x) { <span style="font-weight:bold;text-decoration:underline">return</span> x &lt;= m ? s[x] : S[n / x]; }
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">inline</span> uint <span style="color:#666;font-weight:bold;font-style:italic">getf</span>(ll x) { <span style="font-weight:bold;text-decoration:underline">return</span> x &lt;= m ? f[x] : F[n / x]; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">my_sqrt</span>(ll x) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> r = 1;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">while</span>(1ll * (r + 1) * (r + 1) &lt;= x) ++ r;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">return</span> r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">init</span>(ll _n) {
</span></span><span style="display:flex;"><span>  m = my_sqrt(n = _n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= m; ++i) {
</span></span><span style="display:flex;"><span>    val[i] = 81 * i * i - 27 * i + 9;
</span></span><span style="display:flex;"><span>    s[i] = i - 1;
</span></span><span style="display:flex;"><span>    S[i] = (n / i) - 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> p = 2; p &lt;= m; ++p) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span>(s[p] == s[p-1]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>    prime[pcnt ++] = p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">const</span> uint _s = s[p - 1];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">const</span> ll q = 1ll * p * p, lim = min((ll) m, n / q), x = m / p, y = n / p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= x; ++i) S[i] -= S[i * p] - _s;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i = x + 1; i &lt;= lim; ++i) S[i] -= s[y / i] - _s;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i = m; i &gt;= q; --i) s[i] -= s[i / p] - _s;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= m; ++i) {
</span></span><span style="display:flex;"><span>    f[i] = s[i] * 63;
</span></span><span style="display:flex;"><span>    F[i] = S[i] * 63;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> e = pcnt; e &gt;= 1; --e) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> p = prime[e-1];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">const</span> ll q = 1ll * p * p, lim = min((ll) m, n / q);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= lim; ++i) {
</span></span><span style="display:flex;"><span>      ll cur = n / i;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span>(ll t = p, c = 1; t * p &lt;= cur; t *= p, ++ c) {
</span></span><span style="display:flex;"><span>        F[i] += (getf(cur / t) - e * 63) * val[c] + val[c + 1];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i = m; i &gt;= q; --i) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> cur = i;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t = p, c = 1; t &lt;= cur / p; t *= p, ++ c) {
</span></span><span style="display:flex;"><span>        f[i] += (getf(cur / t) - e * 63) * val[c] + val[c + 1];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  </div>

</div>


    </main>
  </div>

  <footer>
    <p>Powered by
    <a href="https://gohugo.io/">Hugo</a>
    and
    <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    © Wearry &gt;_ 2024
</p>
<script id="gallery-script" src="/js/gallery.js"></script>
  </footer>

</body>


<script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    console
    document.body.classList.remove("auto");
    let cls = "light";

    console.log

    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);

  }

  function invert() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    console.log("Setting invert listener");
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invert);
  }

  setTheme();

</script>


</html>