---
title: 互测题总结
date: 2018-10-02 10:58:09
description: 好多不会的题...
categories:
    - 趣题
---

## String

### Description

> 称一个仅由`a`, `b`, `c`组成的字符串 \\(S\\) 是平衡的当且仅当对于 \\(S\\) 的任意一个连续子串 \\(T\\), 任意两种字符的出现次数之差都小于等于 \\(k\\), 求长度为 \\(n\\) 的平衡串的数量.
>
> \\(n \le 10^9, K \le 8\\)

### Solution

定义 \\(f_{a, b}(i)\\) 表示在前 \\(i\\) 个字符中 `a` 和 `b` 出现次数之差, 在只考虑 `a`, `b` 两种字符的条件等价于:

$$\max_{i=1}^{n} f_{a, b}(i) - \min_{i=1}^{n} f_{a, b}(i) \le k$$

注意到如果 \\(f_{a, b}\\) 的值域区间长度为 \\(l\\), 则被所有长度为 \\(k\\) 的值域区间计算的次数是 \\(k - l + 1\\).
记 \\(g(x, y, z)\\) 表示三种 \\(f\\) 的值域区间长度限制分别为 \\(x, y, z\\) 时的方案数, 那么可以容斥计算答案:

$$ans = g(k, k, k) - 3 g(k, k, k-1) + 3 g(k, k-1, k-1) - g(k-1, k-1, k-1)$$

考虑如何计算 \\(g(x, y, z)\\), 以 \\(x\\) 为例, 每一个合法的区间一定可以表示成 \\(s_x + l_x \mid l_x \in [0, x]\\) 的形式.

因为初始状态的 \\(l\\) 确定了 \\(s\\) , 接下来的转移只需要保证 \\(l\\) 的范围即可, 由于:

$$f_{a, b}(i) - f_{a, c}(i) = f_{c, b}(i)$$

考虑对于 \\(z\\) 的限制, 有:

$$s_z + s_y - s_x \le l_x - l_y \le s_z + s_y - s_x + l_z$$

每次转移之前枚举一下 \\(s_z + s_y - s_x\\) 即可, 这样状态只需要考虑 \\(l_x, l_y\\) 即可, 并且初始状态唯一确定 \\(s_x, s_y, s_z\\).

## Sequence

### Description

> 对长度为 \\(n\\) 的序列 \\(\\{a_i\\}\\), 定义 \\(\text{sum}(l, r)\\) 为第 \\(l\\) 到 \\(r\\) 项的元素之和, \\(\text{inc}(l, r)\\) 为第 \\(l\\) 到 \\(r\\) 项的非空上升子序列的最大权值和, 求 \\(\max_{1 \le l,\, r \le n} \text{sum}(l, r) - \text{inc}(l, r)\\), 以及同时满足区间长度最小的 \\((l, r)\\) 的数量.
>
> \\(n \le 2 \times 10^5, |a_i| \le 40\\)

### Solution

由于权值的范围比较小, \\(\text{inc}\\) 的范围也不大, 同时一定存在方案使得 \\(\text{inc}\\) 中只包含正数.

考虑从左到右枚举右端点, 由于最小化区间长度的需要, 记录 \\(dp(i, j)\\) 表示右边界不超过当前枚举的位置, 最长上升子序列的权值和为 \\(i\\) 且最后一位的权值为 \\(j\\) 时最靠右的左端点的位置. 转移可以做到 \\(O(n |a_i|^3)\\)

接下来考虑计算答案, 从大到小枚举 \\(\text{inc}\\) 可能的值, 并求其最靠右的左端点如果左端点是单调增的则说明选择中间这部分的左端点 \\(\text{inc}\\) 会发生变化, 找一个能最优化 \\(\text{sum}\\) 的同时区间长度最小的左端点即可.

## Game

### Description

> \\(n\\) 个人在一起玩游戏每个人初始有一张牌, 牌上的数字构成一个 \\(1-n\\) 的排列, 所有人从左到右进行决策: 翻开自己的牌并留在原地, 或者选一个之前的人与其交换手中的牌并离开游戏, 之前的人将他的牌翻开. 每个人都会采取最佳策略, 并希望自己手中的牌上的数字尽可能大. 定义 \\(E(n)\\) 为 \\(n\\) 个人进行游戏最后留在原地的人的数量的期望.
> 
> $$ \begin{aligned} S_k(n) = \begin{cases}
>    E(n)  & \text{k = 0} \\\\
>     \sum_{i=1}^{n} S_{k-1}(i) & \text{otherwise} \\
> \end{cases}
> \end{aligned} $$
> 
> 求 \\(S_k(n)\\), 保留 10 位有效数字.
>
> \\(k \le 50, n \le 10^{15}\\)

### Solution

首先需要分析每个人的策略, 已知的信息有两部分, 留在原地的人手中的数字集合\\(P\\), 没有进行决策的人手中的数字集合\\(R\\).
证明最优策略下发生交换当且仅当 \\(\min\\{R\\} \lt \max\\{P\\}\\).

不妨使用数学归纳法证明, 对于最后一个做决策的人, 决策正确性显然, 考虑剩下的人:

- 当 \\(\min\\{R\\} > \max\\{P\\}\\) 时, 显然翻开手中的牌无论如何都不会再劣于 \\(\max\\{P\\}\\).
- 当 \\(\min\\{R\\} \lt \max\\{P\\}\\) 时, 考虑反证翻开当前的牌不会比 \\(\max\{P\}\\) 更优:

    - 如果翻开的牌优于 \\(\max\\{P\\}\\), 由于在这之前有 \\(\min\\{R\\} \lt \max\\{P\\}\\), 在最小值被翻出之前接下来的人都会选择与最大的位置交换, 如果最大值所在的位置没有发生变化这个位置最后会变成 \\(\min\\{R\\}\\) 且不会有人再和他交换手中的牌, 否则这个位置需要先变得小于原本的 \\(\max\\{P\\}\\).
    - 如果翻开的牌劣于 \\(\max\\{P\\}\\) 则类似上述情况中先变得小于原本 \\(\max\\{P\\}\\) 的情况, 每一个完整过程中要么 \\(\max\\{P\\}\\) 变成 \\(\min\\{R\\}\\), 要么 \\(\max\\{P\\}\\) 的位置发生变化, 最终一定都会劣于最初的 \\(\max\\{P\\}\\).

接下来考虑 \\(E(n)\\), 第 \\(i\\) 个人选择留在原地当且仅当第 \\(i-1\\) 个人手中的牌恰好是后缀最小值, 于是:

$$E(n) = \sum_{i=1}^{n} \frac{1}{i}$$

考虑生成函数:

$$
\begin{aligned}
F(x) &= \sum_{i=1}^{\infty} \frac{1}{i} x^i \\\\
     &= \int \frac{1}{1 - x} \\\\
     &= -\ln(1 - x) 
\end{aligned}
$$

$$
\begin{aligned}
E(x) &= \frac{F(x)}{1 - x} \\\\
     &= \frac{-\ln(1 - x)}{1 - x}
\end{aligned}
$$

接下来计算 \\(S_k(n)\\):

$$ 
\begin{aligned}
S_k(x) &= \frac{S_{k-1}(x)}{1 - x} \\\\
       &= \frac{-\ln(1 - x)}{(1 - x)^{k + 1}} \\\\
S_k'(x) &= \frac{(-\ln(1-x))'}{(1-x)^{k + 1}} - \ln(1 - x) \left( \frac{1}{(1 - x)^{k+1}} \right)' \\\\
        &= \frac{1}{(1 - x)^{k + 2}} - \ln(1 - x) \left( -\frac{1}{(1 - x)^{2k + 2}} ((1-x)^{k+1})' \right) \\\\
        &= \frac{1}{(1 - x)^{k + 2}} - \ln(1 - x) \frac{(k + 1) (1 - x)^k}{(1 - x)^{2k+2}} \\\\
        &= \frac{1}{(1 - x)^{k + 2}} + (k + 1) S_{k+1}(x)
\end{aligned}
$$

考虑 \\(x^n\\) 项的系数: 

$$(n+1)S_k(n+1)x^n = {n + k + 2 \choose k + 1}x^n + (k + 1) S_{k + 1}(n) x^n$$

$$S_{k+1}(n) = \frac{(n+1)S_k(n+1) - {n + k + 2 \choose k + 1}}{k + 1}$$

对于 \\(S_0(n)\\), 使用调和级数的近似公式计算, 否则递归即可.

## Power

### Description

> \\(n\\) 个连续随机变量, 第 \\(i\\) 个变量 \\(x_i\\) 在 \\([l_i, r_i]\\) 中均匀随机, 求 \\(\max\{ (\sum{x_i})^m, a^m \}\\) 的期望值对 \\(998244353\\) 取模的结果.
>
> \\(n \le 15, m \le 10^8, |a|, |l_i|, |r_i| \le 10^6\\)

### Solution

连续概率实际上是合法的点集在 \\(n\\) 维超立方体中的体积占比, 点集内部用积分计算期望即可. 对于 \\([0, \infty)\\) 范围内的 \\(n\\) 个连续随机变量 \\(\\{x_i\\}\\), 不难归纳得到满足 \\(\sum x_i \le x\\) 的点构成的 \\(n\\) 维超几何体在 \\(n\\) 维空间中的体积是 \\(\frac{x^n}{n!}\\).

考虑 \\(\sum{x_i}\\) 和 \\(a\\) 的大小关系.

- \\(m\\) 为奇数时, 需要考虑两个区间, \\([-\infty, a], [a, \infty]\\).
- \\(m\\) 为偶数时, 需要计算三个区间的答案, \\([-\infty, -a], [-a, a], [a, \infty]\\).

那么要计算在每个区间内部的期望值, 考虑将每个 \\(x_i\\) 表示为 \\(l_i + y_i\\) 或 \\(r_i + y_i\\), \\(2^n\\) 枚举所有不合法的变量集合进行容斥, 对于 \\(\sum y_i \le K\\) 的限制可以转化成计算:

$$\int_{0}^{K} \frac{x^{n-1}}{(n-1)!} g(x) \mathrm{d}x$$

\\(g(x)\\) 表示当 \\(\sum y_i = x\\) 时的答案, 同一个区间内的形式是相同的.

对于 \\(\sum y_i \ge K\\) 的限制可以反过来将每个 \\(x_i\\) 表示为 \\(r_i - y_i\\) 或者 \\(l_i - y_i\\), 限制 \\(-\sum y_i \ge K\\) 可以转化为 \\(\sum y_i \le K\\) 的形式.

## Bizi

### Description

> 给出两棵有根树, 大小分别是 \\(n_1, n_2\\), 可以进行三种操作: 
> 1. 修改: 将一条边的边权从 \\(x\\) 改为 \\(y\\) , 代价为 \\(|x - y| \times c1\\).
> 2. 收缩: 选择一个点, 将它的所有子树连向他的父亲, 代价为这个点到父亲的边权 \\(w \times c2\\).
> 3. 生长: 选择任意一个点的一段连续的子树, 插入一个新点连向选择的点并成为这些子树的父亲, 代价为连向原来的点的边权 \\(w \times c2\\).
>
> 求出使得两颗树括号序列和边权相同需要的最小代价.
>
> \\(n_1 \le 50, n_2 \le 2000\\)

### Solution

首先不难发现操作一和操作二互为逆操作, 所以可以只考虑操作二.

定义 \\(dp(a, b, c, d)\\) 表示第一颗树中 \\([a, b]\\) 表示的括号序列区间和第二棵树中 \\([c, d]\\) 表示的括号序列区间变得相同需要的最小代价, 考虑左端点对应的括号在最终情况下的匹配情况进行转移:

$$
dp(a, b, c, d) = \min \begin{cases} 
dp(a + 1, b, c, d) + w_{a} \times c2 \\\\
dp(a, b, c + 1, d) + w_{c} \times c2 \\\\
dp(a + 1, p_{a} - 1, b + 1, p_{b} - 1) + dp(p_{a} + 1, b, p_{c} + 1, d) + |w_{a} - w_{b}| \times c1
\end{cases}
$$

\\(p_x\\) 表示第 \\(x\\) 个括号的匹配括号的位置, \\(w_x\\) 表示第 \\(x\\) 个括号和其父亲结点之间连边的边权.

看起来状态数是 \\(O(n_1^2n_2^2)\\) 的, 实际上分析后发现有用的状态数只有 \\(O(n_1^2n_2\log{n_2})\\): 
因为考虑左端点进行转移和考虑右端点进行转移是等价的, 但是如果每次都选择第二棵树中子树大小较小的一侧进行转移, 关于第二棵树的状态数就是轻儿子的子树大小之和, 而这个值是不会超过 \\(O(n_2 \log{n_2})\\) 的.

## Circle

### Description

> 平面上有 \\(n\\) 个点, 求有多少个无序三元组 \\((i, j, k)\\) 满足点 \\(i, j, k\\) 确定的圆经过坐标原点.
>
> \\(n \le 2000\\)

### Solution

西姆松定理:

> 三个点确定的圆上任选一点向这三个点构成的三角形三边所在直线分别作垂线, 垂足三点共线.

证明可参考下图:

![](/images/simson.png)

于是问题转化为求三点共线的数量.

## Triangle

### Description

> 有一棵 \\(n\\) 个点的树, 初始时树上没有石子, 可以进行若干次如下操作:
> 1. 如果点 \\(u\\) 的所有子树 \\(v\\) 上都恰好有 \\(w_v\\) 颗石子, 则可以从手中拿出 \\(w_u\\) 颗石子放在点 \\(u\\) 上.
> 2. 将某个结点上的所有石子收回手中.
> 
> 现在询问你对于每一个点 \\(i\\), 要使得 \\(i\\) 上恰好放有 \\(w_i\\) 颗石子, 初始时手中至少需要多少颗石子.
>
> \\(n \le 10^5, w_i \le 10^9\\)

### Solution

首先可以发现操作的过程类似一个拓扑排序, 填上一个结点的石子之前先要将它的所有儿子都填上石子, 接着会立即收回儿子结点上的石子.

不妨反过来考虑, 定义一次操作为选择一个放有石子的点, 将它的儿子结点全部放上石子, 然后收回这个点的石子. 由于只需要考虑操作过程中石子数量的最大值, 可以发现反转顺序并不会影响答案.

用一个二元组 \\((a, b)\\) 描述一次操作, \\(a, b\\) 分别表示在操作的过程中石子的总变化量和变化最大值, 注意到两个操作可以方便地合并:

$$
(a, b) + (c, d) = (a + c, \max\\{b, a + d\\})
$$

接下来考虑二元组 \\(X = (a, b)\\) 和 \\(Y = (c, d)\\) 之间的优先级, 不难得到以下优先级规则:

1. \\(a \times c \lt 0\\) 时, 总变化量小于 \\(0\\) 的二元组优先级更高.
2. \\(a \lt 0 , c \lt 0\\) 时, 变化最大值较小的二元组优先级更高.
3. \\(a > 0 , c > 0\\) 时, 总变化量减去变化最大值较小的二元组优先级更高.

以上规则也可利用交换法证明正确性. 又因为任意两个二元组合并得到的新二元组不会比原来的两个二元组都更优, 所以全局最优的二元组在可以选择的时候一定会马上选择, 于是得到一个贪心策略, 每次选择最优的二元组并将其和父亲当前对应的二元组进行合并, 可以发现这样能够得到整棵树的操作序列.
